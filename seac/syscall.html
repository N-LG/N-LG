<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>SEAC: systeme d'exploitation "aproximativement complet"</title>
<link href="seac.css" rel="stylesheet" type="text/css">
<meta name="robots" content="index,follow">
<meta name="revisit-after" content="14">
<script src="seac.js" type="text/javascript"></script>
<script src="webring_devse.js" type="text/javascript"></script>
</head>
<body onload="initpage()">
<center>



<div class="bloc">


les fonctions système sont appelé avec les interruptions 60h à 6Fh en assembleur ou avec leurs <a href="#fonctionsC">équivalent en C</a><br>
si il y as plusieurs fonction disponible, le numéros de la fonction sera dans le registre al<br>
<p style="widith:300%;">
<a href="#int60">int 60h</a> termine la tache en cours<br>
<a href="#int61">int 61h</a> fonctions générales<br>
<a href="#int62">int 62h</a> force la commutation de tâche<br>
<a href="#int63">int 63h</a> fonctions d'interface<br>
<a href="#int64">int 64h</a> fonctions fichier<br>
<a href="#int65">int 65h</a> fonction de communication inter-tâche<br>
<a href="#int66">int 66h</a> fonctions port série et parallèles<br>
<a href="#int68">int 68h</a> fonctions périphériques usb<br>
</p>
<br>
<a href="#erreurs">codes d'erreurs</a><br>
<a href="#services">codes de service</a><br>


</div>



<div class="bloc">
<h2><a id="int60"></a>int 60h</h2>
termine la tache en cours (pas d'argument)<br>
<table><tr><td>equivalent C</td><td><a href="#C_stop">stop()</a>
</td></tr></table>
</div>



<div class="bloc">
<h2><a id="int61"></a>int 61h</h2>
fonctions générales<br>
<a href="#int61_0">envoyer une commande au système</a><br>
<a href="#int61_1">mettre en veille la tache</a><br>
<a href="#int61_2">obtenir ID</a><br>
<a href="#int61_3">obtenir commande</a><br>
<a href="#int61_4">obtenir option dans commande (par n°)</a><br>
<a href="#int61_5">obtenir option dans commande (par lettre)</a><br>
<a href="#int61_6">écrire une ligne dans le journal</a><br>
<a href="#int61_7">modifier descriptif de la tache</a><br>
<a href="#int61_8">modifier taille d'un segment de la tache</a><br>
<a href="#int61_9">lire la date et l'heure actuelle</a><br>
<a href="#int61_10">déclarer son type de service</a><br>
<a href="#int61_11">rechercher un service</a><br>
<a href="#int61_12">lire compteur temps</a><br>
<a href="#int61_13">obtenir message système</a><br>
<a href="#int61_14">lire le journal</a><br>
<a href="#int61_15">copier des données dans la zone de copier/coller</a><br>
<a href="#int61_16">lire les données dans la zone de copier/coller</a><br>
<a href="#int61_17">effacer la zone de copier/coller</a><br>
<a href="#int61_18">lire le dossier de travail en cours</a><br>
<a href="#int61_19">rechercher les taches que l'on as crée</a><br>
<a href="#int61_100">convertir chaine décimale asciiz en entier 32bits</a><br>
<a href="#int61_101">convertir chaine hexadécimale en entier 32bits</a><br>
<a href="#int61_102">convertir entier 32bits en chaine décimale asciiz</a><br>
<a href="#int61_103">convertir entier 32bits en chaine hexadécimale asciiz</a><br>
<a href="#int61_104">convertir entier 16bits en chaine hexadécimale asciiz</a><br>
<a href="#int61_105">convertir entier 8bits en chaine hexadécimale asciiz</a><br>
<a href="#int61_108">convertir chaine asciiz en adresse Ethernet</a><br> 
<a href="#int61_109">convertir chaine asciiz en adresse ipv4</a><br>
<a href="#int61_110">convertir chaine asciiz en adresse ipv6</a><br>
<a href="#int61_111">convertir adresse Ethernet en chaine asciiz</a><br>
<a href="#int61_112">convertir adresse ipv4 en chaine asciiz</a><br>
<a href="#int61_113">convertir adresse ipv6 en chaine asciiz</a><br>
<a href="#int61_114">convertir chaine utf8Z en GUID/UUID</a>(en cours de dévellopement)<br>
<a href="#int61_115">convertir GUID/UUID en chaine utf8Z</a>(en cours de dévellopement)<br>
<a href="#int61_116">convertir données base64 en données binaires</a><br>
<a href="#int61_117">convertir données binaires en base64</a><br> 
<a href="#int61_118">convertir données binaires en base64url</a><br>
<a href="#int61_119">convertire un compteur temp unix (unix timestamp) en date et heure</a><br> 
<a href="#int61_120">convertire une date et une heure en un compteur temp unix (unix timestamp)</a><br>
<a href="#int61_150">calcul un crc16</a><br>
<a href="#int61_151">calcul un crc32</a><br>
<a href="#int61_152">décompresse une zone compressé par deflate</a><br>
<a href="#int61_153">décompresse un fichier compressé par deflate</a><br>
</div>



<div class="bloc">
<h3><a id="int61_0"></a>envoyer une commande au système</h3>
<table><tr><td>entrées:</td><td>
al = 0<br>ds:edx = pointeur vers la commande a envoyer sous la forme d'une chaine utf8Z
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_cmd">cmd()</a>
</td></tr></table>

<hr>
<h3><a id="int61_1"></a>mettre la tache en pause</h3>
<table><tr><td>entrées:</td><td>
al = 1<br>ecx = durée de la pause divisé par 2.5ms
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_delay">delay()</a>
</td></tr></table>

<hr>
<h3><a id="int61_2"></a>obtenir l'ID de la tâche</h3>
<table><tr><td>entrées:</td><td>
al = 2
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a><br>bx = ID de la tache
</td></tr><tr><td>equivalent C</td><td><a href="#C_id_tache">id_tache()</a>
</td></tr></table>

<hr>
<h3><a id="int61_3"></a>lire la commande qui as appelé la tache</h3>
<table><tr><td>entrées:</td><td>
al = 3<br>ds:edx = zone de 512 octet ou sera écrit la commande
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_arg_tot">arg_tot()</a>
</td></tr></table>

<hr>
<h3><a id="int61_4"></a>lire un argument de la tache (par numéro)</h3>
<table><tr><td>entrées:</td><td>
al = 4<br>ah = numéros de l'argument<br>ds:edx = pointeur vers la zone mémoire ou copier l'argument<br>cl = taille maximum (0=255)
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_arg_num">arg_num()</a>
</td></tr></table>

<hr>
<h3><a id="int61_5"></a>lire un argument de la tache (par lettre)</h3>
<table><tr><td>entrées:</td><td>
al = 5<br>ah = lettre de l'argument<br>ds:edx = pointeur vers la zone mémoire ou copier l'argument<br>cl = taille maximum (0=255)
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_arg_lettre">arg_lettre()</a>
</td></tr></table>

<hr>
<h3><a id="int61_6"></a>ajouter du texte dans le journal systeme</h3>
<table><tr><td>entrées:</td><td>
al = 6<br>ds:edx = pointeur vers le texte a écrire dans le journal sous la forme d'une chaine utf8Z
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_printJ">printJ()</a>
</td></tr></table>

<hr>
<h3><a id="int61_7"></a>modifier le descripteur de la tâche</h3>
<table><tr><td>entrées:</td><td>
al = 7<br>ds:edx = pointeur vers le texte a écrire dans le descripteur de tache sous la forme d'une chaine utf8Z
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_printD">printD()</a>
</td></tr></table>

<hr>
<h3><a id="int61_8"></a>modifier la taille d'un des segment de la tâche</h3>
<table><tr><td>entrées:</td><td>
al = 8<br>dx = sélecteur du segment a modifier<br>ecx = taille du segment souhaité
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_changeT">changeT()</a>
</td></tr></table>

<hr>
<h3><a id="int61_9"></a>lire la date et l'heure</h3>
<table><tr><td>entrées:</td><td>
al = 9
</td></tr><tr><td>sorties:</td><td>
bh = heure<br>bl = minute<br>si = seconde (en millième)<br>dl = jour<br>dh = mois<br>cx = année
</td></tr><tr><td>equivalent C</td><td><a href="#C_lireDH">lireDH()</a>
</td></tr></table>

<hr>
<h3><a id="int61_10"></a>change le code de service de la tâche</h3>
<table><tr><td>entrées:</td><td>
al = 10<br>ah = <a href="#services">code service</a>
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_changeS">changeS()</a>
</td></tr></table>

<hr>
<h3><a id="int61_11"></a>recherche des services</h3>
<table><tr><td>entrées:</td><td>
al = 11<br>ah = <a href="#services">code service</a> recherché<br>ds:edx = pointeur vers la zone ou copier la table des services<br>cl = nombre de service maximum dans la table
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_rechercheS">rechercheS()</a>
</td></tr></table>

<hr>
<h3><a id="int61_12"></a>lire le compteur temps</h3>
<table><tr><td>entrées:</td><td>
al = 12
</td></tr><tr><td>sorties:</td><td>
eax = 32bit de poids faible du compteur temps<br>edx = 32bit de poids fort du compteur temps
</td></tr></table>

<hr>
<h3><a id="int61_13"></a>lire  message système et message d'erreur</h3>
<table><tr><td>entrées:</td><td>
al = 13<br>ah = type de message (0 = système, 1 = erreur)<br>ds:edx = pointeur vers la zone ou copier le message sous la forme d'une chaine utf8Z<br>cl = numéros du message<br>ch = taille maximum du message
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_14"></a>lire le journal système</h3>
<table><tr><td>entrées:</td><td>
al = 14<br>es:edx = pointeur vers la zone ou copier le journal sous la forme d'une chaine utf8Z<br>ecx = taille maximum du message
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_15"></a>copier des données dans le presse papier</h3>
<table><tr><td>entrées:</td><td>
al = 15<br>es:edx = pointeur vers les données a copier<br>ecx = taille des données a copier
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_16"></a>lire des données dans le presse papier</h3>
<table><tr><td>entrées:</td><td>
al = 16<br>es:edx = pointeur vers l'endroit ou il faut écrire le presse papier<br>ecx = taille des données a maximum que l'on peut écrire
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_17"></a>effacer le contenue du presse papier</h3>
<table><tr><td>entrées:</td><td>
al = 17
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_18"></a>lire l'adresse du dossier de travail</h3>
<table><tr><td>entrées:</td><td>
al = 18<br>es:edx = pointeur vers la zone de 512 octet ou copier l'adresse du dossier de travail sous la forme d'une chaine utf8Z
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_19"></a>recherche les taches que l'on as créer</h3>
<table><tr><td>entrées:</td><td>
al = 11<br>ds:edx = pointeur vers la zone ou copier la table des id de tache<br>cl = nombre de tache maximum dans la table
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">code d'erreur</a>
</td></tr></table>



<hr>
<h3><a id="int61_100"></a>convertir une chaine de caractère représentant un nombre décimal</h3>
<table><tr><td>entrées:</td><td>
al = 100<br>ds:edx = pointeur vers la chaine a convertir
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ecx = valeur de ce nombre
</td></tr></table>

<hr>
<h3><a id="int61_101"></a>convertir une chaine de caractère représentant un nombre hexadécimal</h3>
<table><tr><td>entrées:</td><td>
al = 101<br>ds:edx = pointeur vers la chaine a convertir
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ecx = valeur de ce nombre
</td></tr></table>

<hr>
<h3><a id="int61_102"></a>convertir un nombre 32bits en une chaine de caractère de sa représentation décimal</h3>
<table><tr><td>entrées:</td><td>
al = 102<br>ecx = nombre<br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_103"></a>convertir un nombre 32bits en une chaine de caractère de sa représentation hexadécimal</h3>
<table><tr><td>entrées:</td><td>
al = 103<br>ecx = nombre<br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_104"></a>convertir un nombre 16bits en une chaine de caractère de sa représentation hexadécimal</h3>
<table><tr><td>entrées:</td><td>
al = 104<br>ecx = nombre<br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_105"></a>convertir un nombre 8bits en une chaine de caractère de sa représentation hexadécimal</h3>
<table><tr><td>entrées:</td><td>
al = 105<br>ecx = nombre<br>ds:edx = pointeur vers une zone mémoire de 16 octet ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_108"></a>convertir une chaine de caractère représentant une adresse ethernet en adresse ethernet codé comme dans une trame</h3>
<table><tr><td>entrées:</td><td>
al = 108<br>ds:ecx = pointeur vers l'adresse a convertir<br>ds:edx = pointeur vers une zone mémoire ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_109"></a>convertir une chaine de caractère représentant une adresse ipv4 en adresse ipv4 codé comme dans une trame</h3>
<table><tr><td>entrées:</td><td>
al = 109<br>ds:ecx = pointeur vers l'adresse a convertir<br>ds:edx = pointeur vers une zone mémoire ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_110"></a>convertir une chaine de caractère représentant une adresse ipv6 en adresse ipv6 codé comme dans une trame</h3>
<table><tr><td>entrées:</td><td>
al = 110<br>ds:ecx = pointeur vers l'adresse a convertir<br>ds:edx = pointeur vers une zone mémoire ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_111"></a>convertir adresse ethernet codé comme dans une trame en une chaine de caractère représentant une adresse ethernet</h3>
<table><tr><td>entrées:</td><td>
al = 111<br>ds:ecx = pointeur vers la a zone ou ser copié le résultat<br>ds:edx = pointeur vers la chaine de caractère a convertir
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_112"></a>convertir adresse ipv4 codé comme dans une trame en une chaine de caractère représentant une adresse ipv4</h3>
<table><tr><td>entrées:</td><td>
al = 112<br>ds:ecx = pointeur vers la a zone ou ser copié le résultat<br>ds:edx = pointeur vers la chaine de caractère a convertir
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_113"></a>convertir adresse ipv6 codé comme dans une trame en une chaine de caractère représentant une adresse ipv6</h3>
<table><tr><td>entrées:</td><td>
al = 113<br>ds:ecx = pointeur vers la a zone ou ser copié le résultat<br>ds:edx = pointeur vers la chaine de caractère a convertir
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_116"></a>convertir une chaine Base64(tout type) en binaire</h3>
<table><tr><td>entrées:</td><td>
al = 116<br>ds:esi = chaine en base64 a convertir<br>ecx = taille de la chaine<br>ds:edi = pointeur vers une zone mémoire ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_117"></a>convertir donnée binaire en une chaine Base64 générale</h3>
<table><tr><td>entrées:</td><td>
al = 117<br>ds:esi = données binaire a convertir<br>ecx = taille des donnée<br>ds:edi = pointeur vers une zone mémoire ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_118"></a>convertir donnée binaire en une chaine Base64 pour Url </h3>
<table><tr><td>entrées:</td><td>
al = 118<br>ds:esi = données binaire a convertir<br>ecx = taille des donnée<br>ds:edi = pointeur vers une zone mémoire ou sera copié le résultat
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int61_119"></a>convertire un compteur temp unix (unix timestamp) en date et heure </h3>
<table><tr><td>entrées:</td><td>
al = 119<br>ecx = lsb du comteur temp<br>edx = msb du compteur temp
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>bh = heure<br>bl = minute<br>si = seconde (en millième)<br>dl = jour<br>dh = mois<br>cx = année
</td></tr></table>

<hr>
<h3><a id="int61_120"></a>convertire une date et une heure en un compteur temp unix (unix timestamp)</h3>
<table><tr><td>entrées:</td><td>
al = 119<br>bh = heure<br>bl = minute<br>si = seconde (en millième)<br>dl = jour<br>dh = mois<br>cx = année
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ecx = lsb du comteur temp<br>edx = msb du compteur temp
</td></tr></table>

<hr>
<h3><a id="int61_150"></a>calcul un CRC16</h3>
<table><tr><td>entrées:</td><td>
al = 150<br>ds:esi = début de la chaine<br>ecx = Nb d'octet de la chaine<br>bx = valeur initiale du CRC<br>dx = "polynome"
</td></tr><tr><td>sorties:</td><td>
ax = valeur du CRC
</td></tr></table>

<hr>
<h3><a id="int61_151"></a>calcul un CRC32</h3>
<table><tr><td>entrées:</td><td>
al = 151<br>ds:esi = début de la chaine<br>ecx = Nb d'octet de la chaine<br>ebx = valeur initiale du CRC<br>edx = "polynome"
</td></tr><tr><td>sorties:</td><td>
eax = valeur du CRC
</td></tr></table>

<hr>
<h3><a id="int61_152"></a>décompression deflate</h3>
<table><tr><td>entrées:</td><td>
al = 152<br>ds:esi = pointeur vers les données a décompresser<br>es:edi =  pointeur ver la zone ou seront décompressé les données
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>esi = nombre d'octet de la partie compressé<br>edi = nombre d'octet de la partie decompressé
</td></tr></table>

<hr>
<h3><a id="int61_153"></a>décompression de fichier deflate</h3>
<table><tr><td>entrées:</td><td>
al = 153<br>edx = adresse dans le fichier ou se trouve les données compressé<br>esi = n° du descripteur du fichier compressé<br>edi =  n° du descripteur du fichier ou seront décopressé les données
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>esi = nombre d'octet de la partie compressé<br>edi = nombre d'octet de la partie decompressé
</td></tr></table>
</div>



<div class="bloc">
<h2><a id="int62"></a>int 62h</h2>
force la commutation de tâche (pas d'argument)<br>
<table><tr><td>equivalent C</td><td><a href="#C_raf">raf()</a></td></tr></table>
<hr>
<h2><a id="int63"></a>int 63h</h2>
fonctions d'interface<br>


<a href="#int63_0">création console</a><br>
<a href="#int63_1">suppression console</a><br>
<a href="#int63_2">obtenir information écran</a><br>
<a href="#int63_3">change la console affiché</a><br>
<a href="#int63_5">obtient le caractère+touche de la fifo de réception clavier</a><br>
<a href="#int63_6">acquisition d'une chaine de caractère validé par entrée</a><br>
<a href="#int63_7">demande la mise a jour complète de l'écran</a><br>
<a href="#int63_8">demande la mise a jour partielle de l'écran</a><br>
<a href="#int63_10">écrire une chaine utf8Z a une position défini</a><br>
<a href="#int63_11">écrire une chaine a la position du curseur</a><br>
<a href="#int63_12">définir la position du curseur</a><br>
<a href="#int63_13">système de choix par menu</a><br>
<a href="#int63_14">barre de progression mode texte</a><br>
<a href="#int63_21">dessine un pixel a la position x y avec une couleur prédéterminé</a><br>
<a href="#int63_22">dessiner un carré de couleur avec une couleur prédéterminé</a><br>
<a href="#int63_23">dessiner un segment avec une couleur prédéterminé</a><br>
<a href="#int63_24">dessiner un disque avec une couleur prédéterminé</a><br>
<a href="#int63_25">écrire une chaine a la position x y</a><br>
<a href="#int63_26">écrire une chaine a la position x y suivant une largeur maximale</a><br>
<a href="#int63_27">écrire une image a la position x y</a><br>
<a href="#int63_50">crée une image vide</a><br>
<a href="#int63_51">lit les caractéristiques d'un fichier image</a><br>
<a href="#int63_52">lit l'image d'un fichier image</a><br>
<a href="#int63_53">déplace une image avec réadaptation de la taille</a><br>
<a href="#int63_54">déplace un fragment d'image</a><br>
<a href="#int63_55">insère une image dans une autre</a><br>
</div>



<div class="bloc"><h3><a id="int63_0"></a>création console</h3>
<table><tr><td>entrées:</td><td>
al = 0<br>ah = options<br>dx = selecteur du segment a uttiliser pour la console
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_1"></a>fermeture console</h3>
<table><tr><td>entrées:</td><td>
al = 1
</td></tr><tr><td>sorties:</td><td>
aucunes sorties
</td></tr></table>

<hr>
<h3><a id="int63_2"></a>lit les caractéristiques de l'écran</h3>
<table><tr><td>entrées:</td><td>
al = 2<br>ds:edx = pointeur ou copier la table des informations (voir ci dessous)
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_3"></a>changement console affiché</h3>
<table><tr><td>entrées:</td><td>
al = 3<br>dx = id de la tâche que l'on souhaite afficher
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_5"></a>lecture saisie clavier</h3>
<table><tr><td>entrées:</td><td>
al = 5
</td></tr><tr><td>sorties:</td><td>
al = code de touche ou du bouton souris (valeurs F0h à FFh)<br>ah = état des touche spéciales<br>ebx = 0 ou position X si souris<br>ecx = caractère associé a la touche ou position Y si souris
</td></tr></table>

<hr>
<h3><a id="int63_6"></a>acquisition d'une chaine</h3>
<table><tr><td>entrées:</td><td>
al = 6<br>ah = couleur<br>ds:edx=adresse ou sera ecrit la chaine (avec chaine de pré remplissage obligatoire)<br>ecx = nombre d'octet max
</td></tr><tr><td>sorties:</td><td>
al = code touche qui a validé la saisie
</td></tr></table>

<hr>
<h3><a id="int63_7"></a>demande la mise a jour complète de l'écran</h3>
<table><tr><td>entrées:</td><td>
al = 7
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_8"></a>demande la mise a jour partielle de l'écran</h3>
<table><tr><td>entrées:</td><td>
al = 8<br>ebx = coordonnée X coin supérieur gauche<br>ecx = coordonnée Y coin supérieur gauche<br>esi = coordonné X coin inférieur droit<br>edi = coordonné X coin inférieur droit
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_10"></a>écrire une chaine utf8Z a une position défini</h3>
<table><tr><td>entrées:</td><td>
al = 10<br>ah = couleur<br>ds:edx = pointeur vers chaine de caractère utf8z<br>ebx = position en X<br>ecx = position en Y
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_11"></a>écrire une chaine a la position du curseur</h3>
<table><tr><td>entrées:</td><td>
al = 11<br>ah = couleur<br>ds:edx = pointeur vers chaine de caractère utf8z
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>


<hr>
<h3><a id="int63_12"></a>définir la position du curseur</h3>
<table><tr><td>entrées:</td><td>
al = 12<br>ebx = position en X<br>ecx = position en Y
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>


<hr>
<h3><a id="int63_13"></a>système de choix par menu</h3>
<table><tr><td>entrées:</td><td>
al = 13<br>bl = ligne preselectionné<br>bh = couleur de base (3bits)<br>cl = première ligne du menu<br>ch = nombre de ligne  
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>bl = ligne selectionné<br>bh = touche qui as validé
</td></tr></table>

<hr>
<h3><a id="int63_14"></a>barre de progression mode texte</h3>
<table><tr><td>entrées:</td><td>
al = 14<br>esi = progression<br>edi = total<br>ebx = position X de la barre<br>ecx = position Y de la barre<br>edx = taille de la barre en nombre de caractère
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>
;?????????????????????????????
<hr>
<h3><a id="int63_21"></a>dessine un pixel a la position x y avec une couleur prédéterminé</h3>
<table><tr><td>entrées:</td><td>
al = 21<br>ah = bit par pixel de la couleur<br>bx = position X<br>cx = position Y<br>edx = couleur 
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_22"></a>dessiner un carré de couleur avec une couleur prédéterminé</h3>
<table><tr><td>entrées:</td><td>
al = 22<br>ah = bit par pixel de la couleur<br>bx = coordonnée X coin supérieur gauche<br>cx = coordonnée Y coin supérieur gauche<br>si = coordonné X coin inférieur droit<br>di = coordonné X coin inférieur droit<br>edx = couleur 
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_23"></a>dessiner un segment avec une couleur prédéterminé</h3>
<table><tr><td>entrées:</td><td>
al = 23<br>ah = bit par pixel de la couleur<br>bx = coordonnée X début<br>cx = coordonnée Y début<br>si = coordonné X fin<br>di = coordonné X fin<br>edx = couleur
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_24"></a>dessiner un disque avec une couleur prédéterminé</h3>
<table><tr><td>entrées:</td><td>
al = 24<br>ah = bit par pixel de la couleur<br>bx = position X<br>cx = position Y<br>edx = couleur<br>esi=rayon du cercle
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_25"></a>écrire une chaine a la position x y</h3>
<table><tr><td>entrées:</td><td>
al = 25<br>ah = couleur<br>bx = position X<br>cx = position Y<br>ds:edx = pointeur vers la chaine utf8Z
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_26"></a>écrire une chaine a la position x y suivant une largeur maximale</h3>
<table><tr><td>entrées:</td><td>
al = 26<br>ah = couleur<br>bx = position X<br>cx = position Y<br>ds:edx = pointeur vers la chaine utf8Z<br>esi = nombre de caractère max en largeur
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_27"></a>écrire une image a la position x y</h3>
<table><tr><td>entrées:</td><td>
al = 27<br>bx = position X<br>cx = position Y<br>ds:edx = pointeur vers une image au format BMS
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_50"></a>crée une image vide</h3>
<table><tr><td>entrées:</td><td>
al = 50<br>ah = nombre de bit par couleur<br>ebx = largeur de l'image<br>ecx = hauteur de l'image<br>edx = couleur de l'image<br>ds:edi=position de l'image
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_51"></a>lit les caractéristiques d'un fichier image</h3>
<table><tr><td>entrées:</td><td>
al = 51<br>ebx = Id du fichier image
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ebx = largeur de l'image<br>ecx = hauteur de l'image<br>edx = [24MSB = taille image au format BMS 8LSB = bit par pixel]
</td></tr></table>

<hr>
<h3><a id="int63_52"></a>lit l'image d'un fichier image</h3>
<table><tr><td>entrées:</td><td>
al = 52<br>ebx = Id du fichier image<br>es:edi = adresse ou copier l'image
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_53"></a>déplace une image avec réadaptation de la taille</h3>
<table><tr><td>entrées:</td><td>
al = 53<br>ds:esi = image d'origine<br>ds:edi = image de sortie
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_54"></a>extrait un fragment d'image</h3>
<table><tr><td>entrées:</td><td>
al = 54<br>ds:esi = image d'origine<br>es:edi = image de sortie<br>ebx = position x du fragment<br>ecx = position y du fragment
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int63_55"></a>insère une image dans une autre</h3>
<table><tr><td>entrées:</td><td>
al = 55<br>ds:esi = image d'origine<br>ds:edi = image de sortie<br>ebx = position x du fragment<br>ecx = position y du fragment
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>
</div>



<div class="bloc">
<h2><a id="int64"></a>int 64h</h2>
fonctions fichier<br>

<a href="#int64_0">ouvrir fichier</a><br>
<a href="#int64_1">fermer le fichier</a><br>
<a href="#int64_2">créer fichier</a><br>
<a href="#int64_3">supprimer fichier</a><br>
<a href="#int64_4">lit le fichier</a><br>
<a href="#int64_5">ecrire dans le fichier</a><br>
<a href="#int64_6">lit les attributs d'un fichier</a><br>
<a href="#int64_7">ecrire les attributs d'un fichier</a><br>
<a href="#int64_8">lire dans un secteur</a><br>
<a href="#int64_9">ecrire dans un secteur</a><br>
<a href="#int64_10">lire les information d'un disque</a><br>
<a href="#int64_11">définit le msb du numéros de secteur lors des fonction 8 et 9</a>(en cours de dévellopement)<br>
<a href="#int64_12">met a jour la table des partition d'un disque</a><br>
<a href="#int64_13">definis vitesse disque</a>(en cours de dévellopement)<br>
<a href="#int64_14">définis le msb de l'adresse de lecture/ecriture fichier (fonction 4 et 5)</a>(en cours de dévellopement)<br>
<a href="#int64_15">réserve espace pour fichier</a><br>
<a href="#int64_16">lit contenue répertoire</a><br>
<a href="#int64_17">lit disques disponible</a><br>
<a href="#int64_18">lit nombre de secteur et taille secteur</a><br>
</div>



<div class="bloc"><h3><a id="int64_0"></a>ouvrir fichier</h3>
<table><tr><td>entrées:</td><td>
al = 0<br>ds:edx = chaine de caractère du nom du fichier a ouvrir<br>ebx = numéros de dossier qui contient
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>bx=numéros du fichier
</td></tr><tr><td>equivalent C</td><td><a href="#C_open_file">open_file()</a>
</td></tr></table>

<hr>
<h3><a id="int64_1"></a>fermer fichier</h3>
<table><tr><td>entrées:</td><td>
al = 1<br>ebx = numéros du fichier a fermer  
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_close_file">close_file()</a>
</td></tr></table>

<hr>
<h3><a id="int64_2"></a>créer fichier</h3>
<table><tr><td>entrées:</td><td>
al = 2<br>ds:edx = chaine de caractère du nom du fichier a créer<br>ebx = numéros de dossier qui contiendra le fichier
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>bx=numéros du fichier
</td></tr><tr><td>equivalent C</td><td><a href="#C_create_file">create_file()</a>
</td></tr></table>

<hr>
<h3><a id="int64_3"></a>supprimer fichier</h3>
<table><tr><td>entrées:</td><td>
al = 3<br>ebx = numéros du fichier a fermer
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_delete_file">delete_file()</a>
</td></tr></table>

<hr>
<h3><a id="int64_4"></a>lit le fichier</h3>
<table><tr><td>entrées:</td><td>
al = 4<br>es:edi = zone ou copier les données<br>ebx = numéros du fichier ouvert<br>edx = offset dans le fichier<br>ecx = quantité a lire
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_read_file">read_file()</a>
</td></tr></table>

<hr>
<h3><a id="int64_5"></a>ecrire dans le fichier</h3>
<table><tr><td>entrées:</td><td>
al = 5<br>es:esi = adresse des données a copier<br>ebx = numéros du fichier ouvert<br>edx = offset dans le fichier<br>ecx = quantité a ecrire
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr><tr><td>equivalent C</td><td><a href="#C_write_file">write_file()</a>
</td></tr></table>

<hr>
<h3><a id="int64_6"></a>lit les attributs d'un fichier</h3>
<table><tr><td>entrées:</td><td>
al = 6<br>ah = type d'attribut a lire(0=nom 1=taille fichier 2=attributs)<br>ebx = numéros du fichier<br>ds:edx=destination des données demandé
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int64_7"></a>ecrire les attributs d'un fichier</h3>
<table><tr><td>entrées:</td><td>
al = 7<br>ah = type d'attribut a modifier(0=nom 1=taille fichier 2=attributs)<br>ebx = numéros du fichier<br>ds:edx = données demandé
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int64_8"></a>lire dans un secteur</h3>
<table><tr><td>entrées:</td><td>
al = 8<br>ch = n° de disque<br>cl = nombre de secteur a lire<br>ebx = numéros de secteur<br>es:edi = zone de destination
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int64_9"></a>ecrire dans un secteur</h3>
<table><tr><td>entrées:</td><td>
al = 9<br>ch = n° de disque<br>cl = nombre de secteur a lire<br>ebx = numéros de secteur<br>ds:esi = donnée a écrire
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int64_10"></a>lire les information d'un disque</h3>
<table><tr><td>entrées:</td><td>
al = 10<br>ch = n° de disque<br>es:edi = zone de destination
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int64_12"></a>met a jour la table des partition d'un disque</h3>
<table><tr><td>entrées:</td><td>
al = 12<br>ch = n° de disque
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<hr>

<hr>
<h3><a id="int64_15"></a>réserve espace pour fichier</h3>
<table><tr><td>entrées:</td><td>
al = 15<br>ebx = numéros de descripteur fichier<br>ecx = taille du fichier a reserver
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int64_16"></a>lit contenue répertoire</h3>
<table><tr><td>entrées:</td><td>
al = 16<br>ds:edi = zt ou copier les données<br>ecx = taille max<br>edx = premier fichier a lire
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ebx = nombre de fichier chargé dans la zt
</td></tr></table>

<hr>
<h3><a id="int64_17"></a>lit disques disponible</h3>
<table><tr><td>entrées:</td><td>
al = 17<br>ds:edx = pointeur ou copier le bitmap de 32 octet
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

octet 0 à 15 partitions
octet 16 a 19 usb
octet 20 a 23 sata
octet 24 a 28 reservé
octet 29 = b0-b6 reservé b7= disquette 
octet 30 = cdrom (ide+sata)
octet 31 = ata/atapi  


<hr>
<h3><a id="int64_18"></a>lit nombre de secteur et taille secteur</h3>
<table><tr><td>entrées:</td><td>
al = 18<br>ch = numéros de disque
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ecx = taille des secteurs<br>edx = msb nb de secteur<br>ebx = lsb nb de secteur
</td></tr></table>
</div>



<div class="bloc">
<h2><a id="int65"></a>int 65h</h2>
fonction de communication inter-tâche<br>

<a href="#int65_0">ouverture canal</a><br>
<a href="#int65_1">fermeture canal</a><br>
<a href="#int65_2">tester changement descripteur</a><br>
<a href="#int65_3">tester donnée disponible sur canaux</a><br>
<a href="#int65_4">lire descripteur</a><br>
<a href="#int65_5">ecrire descripteur</a><br>
<a href="#int65_6">lire donnée sur canal</a><br>
<a href="#int65_7">envoyer donnée sur canal</a><br>
<a href="#int65_8">attendre changement descripteur sur canal</a><br>
<a href="#int65_9">attendre donnée disponible sur canal</a><br>
<a href="#int65_10">lire info sur canal</a><br>
</div>



<div class="bloc">
<h3><a id="int65_0"></a>ouverture canal</h3>
<table><tr><td>entrées:</td><td>
al = 0<br>bx = ID de la tache avec qui communiquer<br>ecx = taille du descripteur<br>edx = attribut canal<br>esi = taille de la zone tampon d'envoie ou masque d'alignement mode 2<br>edi = taille de la zone tampon de reception
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ebx = adresse de la zone dans la mémoire haute<br>edx = adresse physique du descripteur
</td></tr></table>

<hr>
<h3><a id="int65_1"></a>fermeture canal</h3>
<table><tr><td>entrées:</td><td>
al = 1<br>ebx = adresse du canal dans la mémoire haute
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int65_2"></a>tester changement descripteur</h3>
<table><tr><td>entrées:</td><td>
al = 2
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ebx = adresse du canal dans la mémoire haute
</td></tr></table>

<hr>
<h3><a id="int65_3"></a>tester donnée disponible sur canaux</h3>
<table><tr><td>entrées:</td><td>
al = 3
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a><br>ebx = adresse du canal dans la mémoire haute
</td></tr></table>

<hr>
<h3><a id="int65_4"></a>lire descripteur</h3>
<table><tr><td>entrées:</td><td>
al = 4<br>ebx = adresse du canal dans la mémoire haute<br>ecx = quantité a lire<br>esi = adresse dans la zone<br>es:edi = desitination
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int65_5"></a>ecrire descripteur</h3>
<table><tr><td>entrées:</td><td>
al = 5<br>ebx = adresse du canal dans la mémoire haute<br>ecx = quantité a lire<br>edi = adresse dans la zone<br>ds:esi = origine des données
</td></tr><tr><td>sorties:</td><td>
eax = <a href="#erreurs">codes d'erreurs</a>
</td></tr></table>

<hr>
<h3><a id="int65_6"></a>lire donnée sur canal</h3>
<table><tr><td>entrées:</td><td>
al = 6<br>ebx = adresse du canal dans la mémoire haute<br>ecx = taille des donnée maximum a lire<br>es:edi = zone ou seront écrite les données
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur<br>ecx = taille des données lue
</td></tr></table>

<hr>
<h3><a id="int65_7"></a>envoyer donnée sur canal</h3>
<table><tr><td>entrées:</td><td>
al = 7<br>ebx = adresse du canal dans la mémoire haute<br>ecx = taille des donnée a envoyer<br>ds:esi = données a envoyer
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur<br>ecx = taille des données écrite
</td></tr></table>

<hr>
<h3><a id="int65_8"></a>attendre changement descripteur sur canal</h3>
<table><tr><td>entrées:</td><td>
al = 8<br>ebx = adresse du canal dans la mémoire haute<br>ecx = temps a attendre
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int65_9"></a>attendre donnée disponible sur canal</h3>
<table><tr><td>entrées:</td><td>
al = 9<br>ebx = adresse du canal dans la mémoire haute<br>ecx = temps a attendre
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int65_10"></a>lire info sur canal</h3>
<table><tr><td>entrées:</td><td>
al = 10<br>ebx = adresse du canal dans la mémoire haute
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur<br>bx = ID de la tache au bout du canal<br>ecx = taille du descripteur<br>edx = attribut canal<br>esi = taille de la zone tampon d'envoie<br>edi = taille de la zone tampon de reception<br>ebp = données en attente de lecture
</td></tr></table>
</div>



<div class="bloc"><h2><a id="int66"></a>int 66h</h2>
fonctions port série et parallèles<br>
<a href="#int66_0">envoyer octet</a><br>
<a href="#int66_1">envoyer chaine</a><br>
<a href="#int66_2">reçevoir octet</a><br>
<a href="#int66_3">reçevoir chaine</a><br>
<a href="#int66_4">lecture des bit de controle des ports</a><br>
<a href="#int66_5">ecriture des bit de controle des ports</a><br>
<a href="#int66_6">configurer port</a><br>
<a href="#int66_7">reserver accès port</a><br>
<a href="#int66_8">liberer accès port</a><br>
<a href="#int66_9">changer la taille de la zt de reception</a><br>
</div>



<div class="bloc">
<h3><a id="int66_0"></a>envoyer octet</h3>
<table><tr><td>entrées:</td><td>
al = 0<br>ah = numéros de port<br>cl = octet a envoyer
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

numéros de port<br>
<table>
<tr><td>0 à 7</td><td>Port COM 1 à COM 8</td></tr>
<tr><td>8 à 15</td><td>Port LPT 1 à LPT 8</td></tr>
</table>

<hr>
<h3><a id="int66_1"></a>envoyer chaine</h3>
<table><tr><td>entrées:</td><td>
al = 1<br>ah = numéros de port<br>es:esi = donnée a envoyer<br>ecx = nombre d'octet a envoyer
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int66_2"></a>reçevoir octet</h3>
<table><tr><td>entrées:</td><td>
al = 2<br>ah = numéros de port
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur<br>cl = octet reçu
</td></tr></table>

<hr>
<h3><a id="int66_3"></a>reçevoir chaine</h3>
<table><tr><td>entrées:</td><td>
al = 3<br>ah = numéros de port<br>es:edi = zone ou ecrire les données<br>ecx = nombre d'octet a reçevoir maximum
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int66_4"></a>lecture des bit de controle des ports</h3>
<table><tr><td>entrées:</td><td>
al = 4<br>ah = numéros de port
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur<br>ecx = bit d'état
</td></tr></table>

bit de controle pour port COM<br>
<table>
<tr><td>0</td><td>DTR</td></tr>
<tr><td>1</td><td>RTS</td></tr>
<tr><td>2</td><td>CTS</td></tr>
<tr><td>3</td><td>DSR</td></tr>
<tr><td>4</td><td>RI</td></tr>
<tr><td>5</td><td>DCD/RLSD</td></tr>
</table>

bit de controle pour port LPT<br>
<table>
<tr><td>0</td><td>saut de page</td></tr>
<tr><td>1</td><td>reset</td></tr>
<tr><td>2</td><td>selection périphérique</td></tr>
<tr><td>3</td><td>signal erreur</td></tr>
<tr><td>4</td><td>signal périphérique on line</td></tr>
<tr><td>5</td><td>signal plus de papier</td></tr>
</table>


<hr>
<h3><a id="int66_5"></a>ecriture des bit de controle des ports</h3>
<table><tr><td>entrées:</td><td>
al = 5<br>ah = numéros de port<br>ecx = bit d'état
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int66_6"></a>configurer port com</h3>
<table><tr><td>entrées:</td><td>
al = 6<br>ah = numéros de port<br>ecx = vitesse du port (max 115200bit/s)<br>dl = attribut
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

détail des attributs<br>
<table>
<tr><td>0</td><td>0 = 7 bits par caractère 1 = 8bit par caractère</td></tr>
<tr><td>1</td><td>innutilisé</td></tr>
<tr><td>2</td><td>0 = 1 bit de stop, 1 =  2 bit de stop </td></tr>
<tr><td>3</td><td>0 = pas de bit de parité, 1 = présence d'un bit de parité</td></tr>
<tr><td>4</td><td>0 = parité impaire(odd), 1 = parité paire(even)</td></tr>
</table>

<hr>
<h3><a id="int66_7"></a>reserver accès port</h3>
<table><tr><td>entrées:</td><td>
al = 7<br>ah = numéros de port
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int66_8"></a>liberer accès port</h3>
<table><tr><td>entrées:</td><td>
al = 8<br>ah = numéros de port
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int66_9"></a>changer la taille de la zt de reception d'un port com</h3>
<table><tr><td>entrées:</td><td>
al = 9<br>ah = numéros de port<br>ecx = taille de la zone tampon de réception
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>
</div>



<div class="bloc">
<h2><a id="int68"></a>int 68h</h2>
fonctions périphériques usb<br>
<a href="#int68_0">réservation périphérique</a><br>
<a href="#int68_1">liberation acces périphérique</a><br>
<a href="#int68_2">lecture descripteur</a><br>
<a href="#int68_3">selection configuration actuelle</a><br>
<a href="#int68_4">lecture configuration actuelle</a>(en cours de dévellopement)<br>
<a href="#int68_5">envoie commande brute</a>(en cours de dévellopement)<br>
<a href="#int68_6">envoie donnée bulk</a>(en cours de dévellopement)<br>
<a href="#int68_7">reception donnée bulk</a>(en cours de dévellopement)<br>
<a href="#int68_8">ouverture connexion isocrone vers terminaison</a>(en cours de dévellopement)<br>
<a href="#int68_9">ouverture connexion interruption vers terminaison</a>(en cours de dévellopement)<br>
<a href="#int68_10">fermeture connexion iso ou int</a>(en cours de dévellopement)<br>
</div>



<div class="bloc">
<h3><a id="int68_0"></a>réservation périphérique</h3>
<table><tr><td>entrées:</td><td>
al = 0<br>bl = adresse du périphérique à reserver
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int68_1"></a>liberation acces périphérique</h3>
<table><tr><td>entrées:</td><td>
al = 1<br>bl = adresse du périphérique à liberer
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int68_2"></a>lecture descripteur</h3>
<table><tr><td>entrées:</td><td>
al = 2<br>bl = adresse du périphérique à liberer<br>bh = terminaison<br>dl = index du descripteur<br>dh = type de descripteur
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>

<hr>
<h3><a id="int68_3"></a>selection configuration actuelle</h3>
<table><tr><td>entrées:</td><td>
al = 3
</td></tr><tr><td>sorties:</td><td>
eax = code d'erreur
</td></tr></table>
</div>



<div class="bloc"><h3><a id="erreurs"></a><h3>codes d'erreurs</h3>
<table>
<tr><td>code</td><td>signification</td></tr>
<tr><td>0</td><td>fonction exécute sans erreur</td></tr>
<tr><td>1</td><td>paramètre incorrecte</td></tr>
<tr><td>2</td><td>erreur de lecture</td></tr>
<tr><td>3</td><td>lecteur/disque/fichier non trouvé</td></tr>
<tr><td>4</td><td>erreur du système de fichier</td></tr>
<tr><td>5</td><td>erreur d'écriture</td></tr>
<tr><td>6</td><td>pas de réponse disque</td></tr>
<tr><td>7</td><td>disque occupé</td></tr>
<tr><td>8</td><td>fichier déjà ouvert</td></tr>
<tr><td>9</td><td>interdiction de lecture</td></tr>
<tr><td>10</td><td>interdiction d'ouverture</td></tr>
<tr><td>11</td><td>plus assez de mémoire</td></tr>
<tr><td>12</td><td>le fichier ouvert est un dossier</td></tr>
<tr><td>13</td><td>erreur d'origine inconnue (normalement jamais utilisé, sauf erreur)</td></tr>
<tr><td>14</td><td>nombre de couleur non reconnue</td></tr>
<tr><td>15</td><td>écran absent</td></tr>
<tr><td>16</td><td>zone tampon vide</td></tr>
<tr><td>17</td><td>zone tampon pleine</td></tr>
<tr><td>18</td><td>contrôleur ne répond pas</td></tr>
<tr><td>19</td><td>contrôleur absent</td></tr>
<tr><td>20</td><td>dossier non vide (dans le cas d'une suppression)</td></tr>
<tr><td>21</td><td>dossier non vide (dans le cas d'une suppression)</td></tr>
<tr><td>22</td><td>caractère interdit dans le nom de fichier</td></tr>
<tr><td>23</td><td>création de fichier impossible</td></tr>
</table>
</div>



<div class="bloc">
<h3><a id="services"></a>codes de services</h3>
<table>
<tr><td>code</td><td>signification</td></tr>
<tr><td>0</td><td>aucun service</td></tr>
<tr><td>1</td><td>écran</td></tr>
<tr><td>2</td><td>camera</td></tr>
<tr><td>3</td><td>imprimante</td></tr>
<tr><td>4</td><td>scanner</td></tr>
<tr><td>5</td><td>son</td></tr>
<tr><td>6</td><td>réseau Ethernet</td></tr>
<tr><td>7</td><td>reseau wifi</td></tr>
<tr><td>8</td><td>service dns</td></tr>
<tr><td>9</td><td></td></tr>
<tr><td>10</td><td>aucun service</td></tr>
<tr><td>11 à 63</td><td>réservé pour les standard</td></tr>
<tr><td>64 à 255</td><td>utilisable</td></tr>
</table>
</div>



<div class="bloc"><h2><a id="fonctionsC"></a>fonction en C</h2>
fonctions systeme pour le C<br>
<a href="#C_stop">stop()</a><br>
<a href="#C_cmd">cmd()</a><br>
<a href="#C_delay">delay()</a><br>
<a href="#C_id_tache">id_tache()</a><br>
<a href="#C_arg_tot">arg_tot()</a><br>
<a href="#C_arg_num">arg_num()</a><br>
<a href="#C_arg_lettre">arg_lettre()</a><br>
<a href="#C_printJ">printJ()</a><br>
<a href="#C_printD">printD()</a><br>
<a href="#C_changeT">changeT()</a><br>
<a href="#C_lireDH">lireDH()</a><br>
<a href="#C_changeS">changeS()</a><br>
<a href="#C_rechercheS">rechercheS()</a><br>
<a href="#C_compteur">compteur()</a><br>
<a href="#C_message_systeme">message_systeme()</a><br>
<a href="#C_message_erreur">message_erreur()</a><br>
<a href="#C_lire_journal">lire_journal()</a><br>
<a href="#C_ecrire_pp">ecrire_pp()</a><br>
<a href="#C_lire_pp">lire_pp()</a><br>
<a href="#C_effacer_pp">effacer_pp()</a><br>
<a href="#C_lire_dossier_travail">lire_dossier_travail()</a><br>
<a href="#C_sous_taches">sous_taches()</a><br>
<a href="#C_deci">deci()</a><br>
<a href="#C_hexa">hexa()</a><br>
<a href="#C_long2deci">long2deci()</a><br>
<a href="#C_long2hexa">long2hexa()</a><br>
<a href="#C_etherS2B">etherS2B()</a><br>
<a href="#C_ipv4S2B">ipv4S2B()</a><br>
<a href="#C_ipv6S2B">ipv6S2B()</a><br>
<a href="#C_etherB2S">etherB2S()</a><br>
<a href="#C_ipv4B2S">ipv4B2S()</a><br>
<a href="#C_ipv6B2S">ipv6B2S()</a><br>
<a href="#C_base64binaire">base64binaire()</a><br>


<a href="#C_raf">raf()</a><br>
<a href="#C_open_file">open_file()</a><br>
<a href="#C_close_file">close_file()</a><br>
<a href="#C_create_file">create_file()</a><br>
<a href="#C_delete_file">delete_file()</a><br>
<a href="#C_read_file">read_file()</a><br>
<a href="#C_write_file">write_file()</a><br>
<a href="#C_taille_file">taille_file()</a><br>
<a href="#C_error_file">error_file()</a><br>
</div>



<div class="bloc"><h3><a id="C_stop"></a>void stop()</h3>
termine la tache en cours<br>

<hr>
<h3><a id="C_cmd"></a>void cmd(char* <em>commande</em>)</h3>
Envoie une commande au systeme<br>
<em>commande</em> = commande a envoyer au systeme<br>

<hr>
<h3><a id="C_delay"></a>void delay(unsigned long <em>temps</em>)</h3>
attend<br>
<em>temps</em> = temps à attendre en milliseconde<br>

<hr>
<h3><a id="C_id_tache"></a>unsigned int id_tache()</h3>
Renvoie l'id de la tache<br>


<hr>
<h3><a id="C_arg_tot"></a>long arg_tot(char *<em>string</em>)</h3>
lit la commande de la tache<br>
<em>string</em> = zone de 512 octet ou sera recopiéla commande<br>

<hr>
<h3><a id="C_arg_num"></a>long arg_num(char <em>numero</em>,char *string)</h3>
lit un argument par son numéros<br>
<em>numero</em> = numéro de l'argument a lire<br>
<em>string</em> = zone de 256 octet ou sera recopié l'argument<br>

<hr>
<h3><a id="C_arg_lettre"></a>long arg_lettre(char <em>lettre</em>,char *<em>string</em>)</h3>
lit un argument par sa lettre<br>
<em>lettre</em> = numéro de l'argument a lire<br>
<em>string</em> = zone de 256 octet ou sera recopié l'argument<br>


<hr>
<h3><a id="C_printJ"></a>void printJ(char *<em>string</em>)</h3>
ecrit dans le journal systeme<br>
<em>string</em> = chaine a ecrire dans le journal<br>

<hr>
<h3><a id="C_printD"></a>void printD(char *<em>string</em>)</h3>
change le descriptif de tache<br>
<em>string</em> = chaine a ecrire dans le descripteur de tache<br>

<hr>
<h3><a id="C_changeT"></a>long changeT(long <em>taille</em>)</h3>
change la taille mémoire occupé par la tache<br>
<em>taille</em> = taille souhaité<br>

<hr>
<h3><a id="C_lireDH"></a>struct dateheure lireDH()</h3>
lire la date et l'heure<br>
renvoie une structure d type dateheure

<hr>
<h3><a id="C_changeS"></a>void changeS(unsigned char <em>service</em>)</h3>
change le service de la tache<br>
<em>service</em> = <a href="#services">code service</a> fournis par l'application<br>

<hr>
<h3><a id="C_rechercheS"></a>unsigned long rechercheS(unsigned char <em>service</em>,unsigned int *table,unsigned char taille)</h3>
recherche une tache par son service<br>
<em>service</em> = <a href="#services">code service</a> recherché<br>
<em>table</em> = table d'int ou seront écrit la liste des id des tache <br>
<em>taille</em> = nombre d'entrée maximum de la table<br>

<hr>
<h3><a id="C_compteur"></a>long compteur()</h3>
lit le compteur temps<br>
<em></em> =<br>

<hr>
<h3><a id="C_message_systeme"></a>void message_systeme(int <em>num</em>,char* <em>chaine</em>)</h3>
charge un message systeme<br>
<em>num</em> = numéros du message a charger<br>
<em>chaine</em> = zone de 256 octet ou seront copié le message systeme<br>

<hr>
<h3><a id="C_message_erreur"></a>void message_erreur(int <em>num</em>,char* <em>chaine</em>)</h3>
charge un message d'erreur<br>
<em>num</em> =  <a href="#erreurs">codes d'erreurs</a><br>
<em>chaine</em> = zone de 256 octet ou seront copié le message d'erreur<br>

<hr>
<h3><a id="C_lire_journal"></a>void lire_journal(char* <em>chaine</em>,long <em>taille</em>)</h3>
lit le journal systeme<br>
<em>chaine</em> = endroit ou copier le journal systeme<br>
<em>taille</em> = nombre d'octet maximum du journal a lire<br>

<hr>
<h3><a id="C_ecrire_pp"></a>void ecrire_pp(char* <em>chaine</em>,long <em>taille</em>)</h3>
ecrire dans le presse papier<br>
<em></em> =<br>

<hr>
<h3><a id="C_lire_pp"></a>void lire_pp(char* chaine,long taille)</h3>
lit dans le presse papier<br>
<em></em> =<br>

<hr>
<h3><a id="C_effacer_pp"></a>void effacer_pp()</h3>
efface le presse papier<br>

<hr>
<h3><a id="C_lire_dossier_travail"></a>void lire_dossier_travail(char* <em>chaine</em>)</h3>
lit le dossier de travail<br>
<em>chaine</em> = espace de 512 octet ou sera copié le dosier de travail<br>

<hr>
<h3><a id="C_sous_taches"></a>void sous_taches(int* <em>table</em>,char <em>nb</em>)</h3>
liste les taches que l'on as créer<br>
<em>table</em> = table ou seront recopié la liste de taches<br>
<em>nb</em> = nombre maximum d'element de cette liste<br>

<hr>
<h3><a id="C_deci"></a>long deci(char *<em>chaine</em>)</h3>
convertit chaine décimal en nombre<br>
<em>chaine</em> = chaine a convertir<br>

<hr>
<h3><a id="C_hexa"></a>long hexa(char *<em>chaine</em>)</h3>
convertit chaine héxadécimal en nombre<br>
<em>chaine</em> = chaine a convertir<br>

<hr>
<h3><a id="C_long2deci"></a>void long2deci(long <em>nombre</em>,char *<em>chaine</em>)</h3>
convertit un nombre en chaine décimal<br>
<em>nombre</em> = nombre a convertir<br>
<em>chaine</em> = chaine de 16 octets ou ecrire la conversion<br>

<hr>
<h3><a id="C_long2hexa"></a>void long2hexa(long <em>nombre</em>,char *<em>chaine</em>)</h3>
convertit un nombre en chaine héxadécimal<br>
<em>nombre</em> = nombre a convertir<br>
<em>chaine</em> = chaine de 16 octets ou ecrire la conversion<br>

<hr>
<h3><a id="C_etherS2B"></a>void etherS2B(char *<em>entrée</em>,char *<em>sortie</em>)</h3>
convertit une adresse ethernet sous forme de chaine en forma binaire<br>
<em>entrée</em> = adresse en format chaine<br>
<em>sortie</em> = adresse en format binaire<br>


<hr>
<h3><a id="C_ipv4S2B"></a>void ipv4S2B(char *<em>entree</em>,char *<em>sortie</em>)</h3>
convertit une adresse ip V4 sous forme de chaine en forma binaire<br>
<em>entrée</em> = adresse en format chaine<br>
<em>sortie</em> = adresse en format binaire<br>

<hr>
<h3><a id="C_ipv6S2B"></a>ipv6S2B(char *<em>entree</em>,char *<em>sortie</em>)</h3>
convertit une adresse ip V6 sous forme de chaine en forma binaire<br>
<em>entrée</em> = adresse en format chaine<br>
<em>sortie</em> = adresse en format binaire<br>

<hr>
<h3><a id="C_etherB2S"></a>void etherB2S(char *<em>entree</em>,char *<em>sortie</em>)</h3>
convertit une adresse ethernet sous forme binaire en chaine<br>
<em>entrée</em> = adresse en format binaire<br>
<em>sortie</em> = adresse en format chaine<br>


<hr>
<h3><a id="C_ipv4B2S"></a>void ipv4B2S(char *<em>entree</em>,char *<em>sortie</em>)</h3>
convertit une adresse ip v4 sous forme binaire en chaine<br>
<em>entrée</em> = adresse en format binaire<br>
<em>sortie</em> = adresse en format chaine<br>


<hr>
<h3><a id="C_ipv6B2S"></a>void ipv6B2S(char *<em>entree</em>,char *<em>sortie</em>)</h3>
convertit une adresse ip v6 sous forme binaire en chaine<br>
<em>entrée</em> = adresse en format binaire<br>
<em>sortie</em> = adresse en format chaine<br>

<hr>
<h3><a id="C_base64binaire"></a>base64binaire(char *<em>entree</em>,char *<em>sortie</em>, long <em>taille</em>)</h3>
convertir une chaine codé en base64 en donnée binaire<br>
<em></em> =<br>

<hr>
<h3><a id="C_raf"></a>void raf()</h3>
passe a la tache suivante<br>

<hr>
<h3><a id="C_open_file"></a>long open_file(char* <em>nom</em>)</h3>
ouvre un fichier, renvoie l'id du fichier ouvert ou -1 si cela as échoué<br>
<em>nom</em> = nom du fichier<br>

<hr>
<h3><a id="C_close_file"></a>long close_file(long <em>id</em>)</h3>
ferme un fichier, renvoie le <a href="#erreurs">codes d'erreur</a> de l'opération<br>
<em>id</em> = id du fichier a fermer<br>

<hr>
<h3><a id="C_create_file"></a>long create_file(long <em>nom</em>)</h3>
crée un fichier, renvoie l'id du fichier ouvert ou -1 si cela as échoué<br>
<em>nom</em> = nom du fichier<br>

<hr>
<h3><a id="C_delete_file"></a>long delete_file(long <em>id</em>)</h3>
supprime un fichier, renvoie le <a href="#erreurs">codes d'erreur</a> de l'opération<br>
<em>id</em> = id du fichier a supprimer<br>

<hr>
<h3><a id="C_read_file"></a>long read_file(long <em>id</em>,long <em>offset</em>,long <em>count</em>,char* <em>data</em>)</h3>
lit dans un fichier, renvoie le <a href="#erreurs">codes d'erreur</a> de l'opération<br>
<em>id</em> = id du fichier a supprimer<br>
<em>offset</em> = adresse dans le fichier<br>
<em>count</em> = nombre d'octet<br>
<em>data</em> = ou seront écrit les donnée lut<br>

<hr>
<h3><a id="C_write_file"></a>long write_file(long <em>id</em>,long <em>offset</em>,long <em>count</em>,char* <em>data</em>)</h3>
ecrit dans un fichier, renvoie le  <a href="#erreurs">codes d'erreur</a> de l'opération<br>
<em>id</em> = id du fichier a supprimer<br>
<em>offset</em> = adresse dans le fichier<br>
<em>count</em> = nombre d'octet<br>
<em>data</em> = donnée a ecrire<br>


<hr>
<h3><a id="C_taille_file"></a>long taille_file(long <em>id</em>)</h3>
lit la taille d'un fichier, renvoie la taille du fichier ouvert ou -1 si cela as échoué<br>
<em>id</em> = id du fichier a supprimer<br>

<hr>
<h3><a id="C_error_file"></a>long error_file()</h3>
donne le code de la dernière <a href="#erreurs">erreur</a> lorsque les fonctions renvoie -1<br>


</div>







</center></body></html>


